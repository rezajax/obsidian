
https://github.com/ambrop72/badvpn


https://www.youtube.com/watch?v=52lTdyu7i6c
https://gist.github.com/1nikolas/4efbfb6b0d37eba8c9ab471c55f5e892
```
sudo wget -O /usr/bin/badvpn-udpgw "https://raw.githubusercontent.com/daybreakersx/premscript/master/badvpn-udpgw64"
sudo touch /etc/rc.local
sudo nano /etc/rc.local

----------------------
#!/bin/sh -e
screen -AmdS badvpn badvpn-udpgw --listen-addr 127.0.0.1:7300
exit 0
----------------------

chmod +x /etc/rc.local
sudo systemctl status rc-local.service
sudo chmod +x /usr/bin/badvpn-udpgw
sudo screen -AmdS badvpn badvpn-udpgw --listen-addr 127.0.0.1:7300
reboot
sudo lsof -i -P -n | grep LISTEN







```


badvpn udpgw این چیه؟ و کی نوشتش آیا اوپن سورسه؟

###### ChatGPT said:

ChatGPT

**BadVPN udpgw** یک ابزار از پروژه‌ی **BadVPN** است که برای بهبود عملکرد VPNها و تونل‌ها استفاده می‌شود.

### **کاربرد udpgw:**

این ابزار به عنوان یک **UDP Gateway** عمل می‌کند و امکان انتقال ترافیک **UDP** از طریق یک تونل **TCP** (مانند VPN یا SSH Tunnel) را فراهم می‌کند. از آنجا که بیشتر تونل‌ها به طور پیش‌فرض فقط **TCP** را پشتیبانی می‌کنند، BadVPN udpgw این مشکل را حل کرده و امکان استفاده از برنامه‌هایی که نیاز به UDP دارند (مانند VoIP، بازی‌های آنلاین، و DNS) را در این تونل‌ها فراهم می‌کند.

### **چه کسی BadVPN را نوشته است؟**

BadVPN توسط **Ambroz Bizjak** ایجاد شده است. او این پروژه را برای استفاده در شبکه‌های خصوصی، تونلینگ، و برخی کاربردهای پیشرفته طراحی کرده است.

### **آیا BadVPN و udpgw اوپن سورس است؟**

بله، **BadVPN** و همه ابزارهای آن، از جمله **udpgw**، اوپن سورس هستند و تحت **GNU GPLv3 License** منتشر شده‌اند. کد منبع آن در GitHub در دسترس است، و هر کسی می‌تواند آن را دانلود کرده، تغییر دهد و استفاده کند.

### **چرا از آن استفاده کنیم؟**

1. **سبک و ساده:** طراحی شده برای اجرا در سیستم‌های سبک، مانند سرورهای کوچک یا حتی روترها.
2. **انعطاف‌پذیری:** می‌توان آن را با انواع تونل‌ها و VPNها ادغام کرد.
3. **قابلیت UDP:** مشکل عدم پشتیبانی تونل‌ها از UDP را رفع می‌کند.

### **چطور نصب و استفاده کنیم؟**

1. **نصب از منبع (Source):** کد را از [ریپوی GitHub](https://github.com/ambrop72/badvpn) دانلود کنید و با استفاده از کامپایلر **CMake**، آن را نصب کنید.
    
    bash
    
    Copy code
    
    `git clone https://github.com/ambrop72/badvpn.git cd badvpn mkdir build cd build cmake .. -DBUILD_NOTHING_BY_DEFAULT=1 -DBUILD_UDPGW=1 make`
    
2. **اجرای سرور udpgw:** دستور زیر را برای اجرای سرور **udpgw** بزنید:
    
    bash
    
    Copy code
    
    `./badvpn-udpgw --listen-addr 127.0.0.1:7300`
    
    این دستور سرور را روی پورت 7300 اجرا می‌کند.
    

### **چطور استفاده کنیم؟**

پس از اجرای udpgw، کلاینت (مثل نرم‌افزارهای تونلینگ) باید تنظیم شود تا ترافیک UDP خود را به این سرور هدایت کند.

اگر اطلاعات بیشتری نیاز داری یا مشکل خاصی پیش آمده، بگو تا کمک کنم! 😊



یعنی ssh خودش udp رو ساپورت نمیکرده ؟

###### ChatGPT said:

ChatGPT

بله، درست متوجه شدی! **SSH** به طور پیش‌فرض فقط از پروتکل **TCP** پشتیبانی می‌کند و **UDP** را مستقیم ساپورت نمی‌کند. این محدودیت به خاطر طراحی SSH است که برای ایجاد تونل‌های امن مبتنی بر **TCP** ساخته شده.

### چرا SSH UDP را ساپورت نمی‌کند؟

1. **TCP vs UDP:**
    - **TCP** (Transmission Control Protocol) برای ارتباطات قابل اطمینان طراحی شده و از ویژگی‌هایی مثل بررسی خطا، شماره‌گذاری بسته‌ها، و تضمین تحویل داده‌ها بهره می‌برد. SSH هم برای استفاده از این قابلیت‌های TCP طراحی شده است.
    - **UDP** (User Datagram Protocol) یک پروتکل سریع و بدون تضمین تحویل است. بیشتر برای مواردی که سرعت مهم‌تر از اطمینان است (مانند استریم، VoIP یا گیمینگ) استفاده می‌شود.
2. **تمرکز SSH بر امنیت TCP:** SSH برای ایجاد یک کانال امن روی پروتکل TCP ساخته شده و اصولاً برای UDP نیازی ندیده است.

### مشکل این محدودیت در تونلینگ SSH

وقتی شما یک **SSH Tunnel** ایجاد می‌کنید، فقط ترافیک **TCP** از تونل عبور می‌کند. اما اگر برنامه‌ای نیاز به **UDP** داشته باشد (مثل **DNS queries**، بازی‌های آنلاین یا **VoIP**)، این تونل به تنهایی کافی نیست.

### نقش BadVPN udpgw

BadVPN udpgw این مشکل را حل می‌کند:

1. **کانورت UDP به TCP:** BadVPN ترافیک **UDP** را می‌گیرد و آن را به ترافیک **TCP** تبدیل می‌کند که از تونل SSH عبور کند.
2. **بازگرداندن UDP:** سمت سرور (یا کلاینت)، این ترافیک TCP مجدداً به UDP تبدیل می‌شود تا برنامه بتواند با آن کار کند.

### چطور BadVPN udpgw کمک می‌کند؟

فرض کن که از SSH Tunnel استفاده می‌کنی:

1. BadVPN روی کلاینت نصب می‌شود و ترافیک UDP را به TCP تبدیل می‌کند.
2. ترافیک TCP از تونل SSH عبور می‌کند.
3. BadVPN سمت سرور ترافیک را دوباره به UDP تبدیل می‌کند و آن را به مقصد ارسال می‌کند.

### نتیجه

با این راه‌حل، می‌توان محدودیت **SSH برای عدم پشتیبانی از UDP** را دور زد و از برنامه‌هایی که نیاز به UDP دارند استفاده کرد. اگر به کانفیگ یا نصب کمک خواستی، بگو! 😊

4o


این نرم افزار مشابه داره؟

###### ChatGPT said:

ChatGPT

بله، چندین نرم‌افزار مشابه به **BadVPN udpgw** وجود دارند که برای عبور ترافیک **UDP** از طریق تونل‌های **TCP** طراحی شده‌اند. برخی از این نرم‌افزارها به طور خاص برای عبور دادن ترافیک UDP از تونل‌های SSH یا VPN استفاده می‌شوند. در اینجا چند نمونه از این ابزارها آورده شده است:

### 1. **OpenVPN**

- **OpenVPN** یک نرم‌افزار قدرتمند برای ایجاد تونل‌های VPN است که به طور پیش‌فرض از **UDP** و **TCP** پشتیبانی می‌کند. البته، زمانی که از **TCP** استفاده می‌کنید، سرعت کمتری نسبت به **UDP** خواهید داشت.
- در صورتی که نیاز به عبور ترافیک **UDP** از یک تونل **TCP** دارید، می‌توانید از تنظیمات و ابزارهای اضافی OpenVPN برای پیاده‌سازی چنین کارکردی استفاده کنید.

### 2. **SSHuttle**

- **SSHuttle** یک ابزار ساده و مفید برای تونل کردن ترافیک است که به طور خودکار ترافیک **UDP** را از طریق **SSH** تونل می‌کند. SSHuttle بیشتر برای عبور ترافیک‌های **TCP** و **UDP** از SSH طراحی شده و نیازی به تنظیمات پیچیده ندارد.
- این ابزار برای کسانی که به دنبال راه‌حلی ساده و سریع برای تونلینگ ترافیک با استفاده از **SSH** هستند مناسب است.

### 3. **Socks5 Proxy**

- استفاده از یک **Socks5 Proxy** نیز یک روش برای عبور ترافیک UDP از تونل‌های TCP است. این پروکسی‌ها می‌توانند ترافیک **UDP** را از طریق یک تونل **TCP** منتقل کنند.
- برای این کار، می‌توانید از ابزارهایی مانند **Shadowsocks** یا **Dante** استفاده کنید که قابلیت پشتیبانی از پروتکل **UDP** را دارند.

### 4. **WireGuard (با تنظیمات خاص)**

- **WireGuard** یک پروتکل VPN جدید و سریع است که به طور پیش‌فرض از UDP استفاده می‌کند. با این حال، در صورتی که نیاز به عبور ترافیک **UDP** از یک تونل **TCP** داشته باشید، می‌توانید از **WireGuard** به همراه ابزارهایی مانند **UDPGW** یا **SSHuttle** برای دسترسی به UDP از طریق TCP استفاده کنید.
- برای استفاده از UDP روی WireGuard، نیازی به تغییرات زیادی نیست، زیرا خود **WireGuard** به طور پیش‌فرض برای UDP طراحی شده است.

### 5. **Stunnel**

- **Stunnel** یک ابزار است که برای تونل کردن ترافیک **TCP** به یک **SSL/TLS** کانال استفاده می‌شود. از این نرم‌افزار می‌توان برای عبور ترافیک UDP از یک تونل TCP استفاده کرد، اگرچه تنظیمات پیچیده‌تری نسبت به ابزارهایی مثل BadVPN دارد.

### 6. **TunSafe**

- **TunSafe** یک ابزار مشابه WireGuard است که برای ساخت تونل‌های VPN سریع طراحی شده. در صورتی که به دنبال یک ابزار VPN با پشتیبانی از **UDP** باشید، می‌توانید از TunSafe استفاده کنید.

### نکات مهم:

- بسیاری از این ابزارها به طور مستقیم **UDP** را از طریق **VPN** یا **SSH** پشتیبانی می‌کنند، اما برای تونل کردن UDP از طریق **TCP** به ابزارهایی مانند **BadVPN udpgw** نیاز دارید.
- برای عملکرد بهینه، مهم است که انتخاب نرم‌افزار بر اساس نیاز خاص شما انجام شود، مثلا اگر فقط نیاز به عبور **UDP** از SSH دارید، **SSHuttle** یا **BadVPN** مناسب‌تر خواهند بود.

اگر نیاز به راهنمایی بیشتر یا تنظیمات خاص دارید، خوشحال می‌شوم کمک کنم! 😊

---
# rc.local

/etc/rc.local این چیه تو لینوکس؟

###### ChatGPT said:

ChatGPT

فایل `/etc/rc.local` در لینوکس یک اسکریپت است که معمولاً برای اجرای دستورات یا اسکریپت‌های سفارشی در هنگام بوت شدن سیستم استفاده می‌شود. این فایل بخشی از **سیستم init** سنتی لینوکس است و در بسیاری از توزیع‌های قدیمی (مانند سیستم‌هایی که از **System V init** استفاده می‌کنند) به طور پیش‌فرض وجود دارد.

### ویژگی‌های فایل `/etc/rc.local`:

1. **اجرای دستورات هنگام بوت**: این فایل پس از انجام مراحل اولیه بوت اجرا می‌شود و معمولاً برای کارهایی مانند راه‌اندازی سرویس‌های خاص یا اجرای اسکریپت‌های کاربر استفاده می‌شود.
    
2. **مجوز اجرا**: باید قابلیت اجرا (executable) داشته باشد. این کار معمولاً با دستور زیر انجام می‌شود:
    
    bash
    
    Copy code
    
    `sudo chmod +x /etc/rc.local`
    
3. **ساختار اسکریپت**: این فایل به صورت یک اسکریپت Shell است و باید با خط `#!/bin/sh` یا مشابه آن شروع شود. همچنین در انتها معمولاً `exit 0` وجود دارد تا نشان دهد اسکریپت با موفقیت اجرا شده است.
    

### نمونه محتوای `/etc/rc.local`:

bash

Copy code

`#!/bin/sh -e # این دستورات هنگام بوت اجرا می‌شوند  echo "System boot completed!" > /var/log/boot.log /usr/bin/my_custom_script.sh  exit 0`

### توجه:

1. **در سیستم‌های جدید**: توزیع‌های مدرن لینوکس (مانند اوبونتو 16.04 به بعد) از **Systemd** به جای **System V init** استفاده می‌کنند. در این سیستم‌ها، فایل `/etc/rc.local` دیگر به طور پیش‌فرض وجود ندارد و ممکن است استفاده از آن غیرفعال باشد.
    
    - اگر بخواهید از این فایل استفاده کنید، می‌توانید به صورت دستی آن را ایجاد کرده و فعال کنید.
2. **فعال‌سازی در Systemd**: اگر بخواهید از `/etc/rc.local` در یک سیستم مبتنی بر Systemd استفاده کنید، می‌توانید یک فایل سرویس برای آن ایجاد کنید:
    
    bash
    
    Copy code
    
    `sudo nano /etc/systemd/system/rc-local.service`
    
    با محتوای زیر:
    
    ini
    
    Copy code
    
    `[Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.local  [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardInput=tty RemainAfterExit=yes  [Install] WantedBy=multi-user.target`
    
    سپس فایل `/etc/rc.local` را ایجاد کرده و executable کنید:
    
    bash
    
    Copy code
    
    `sudo touch /etc/rc.local sudo chmod +x /etc/rc.local`
    
    محتوای اسکریپت خود را داخل آن قرار دهید و سرویس را فعال کنید:
    
    bash
    
    Copy code
    
    `sudo systemctl enable rc-local sudo systemctl start rc-local`
    

### نکته:

در سیستم‌های جدید، بهتر است به جای استفاده از `/etc/rc.local` از قابلیت‌های Systemd مانند **unit files** یا **timer services** استفاده کنید، زیرا مدرن‌تر و قابل اعتمادتر هستند.

4o